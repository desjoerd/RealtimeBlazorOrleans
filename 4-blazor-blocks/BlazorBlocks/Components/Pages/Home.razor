@page "/"

@implements IDisposable

@using Blazor.Diagrams
@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.PathGenerators
@using Blazor.Diagrams.Core.Routers
@using Blazor.Diagrams.Options
@using Excubo.Blazor.Canvas
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Components.Widgets

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

<Canvas @ref="canvas" width="400" height="400" @onmousemove="Callback"></Canvas>

@if (Diagram != null)
{
    <div class="diagram-container">
        <CascadingValue Value="Diagram" IsFixed="true">
            <DiagramCanvas>
            </DiagramCanvas>
        </CascadingValue>
    </div>
}

@code {

    private Canvas canvas;

    private BlazorDiagram Diagram { get; set; }// = SharedState.Diagram;

    protected override Task OnInitializedAsync()
    {
        Diagram = SharedState.Diagram;

        Diagram.Nodes[0].Locked = true;

        return Task.CompletedTask;

        var options = new BlazorDiagramOptions
        {
            AllowMultiSelection = true,
            AllowPanning = true,
            Virtualization =
            {
                Enabled = true,
            },
            Zoom =
            {
                Enabled = true,
            },
            Links =
            {
                DefaultRouter = new NormalRouter(),
                DefaultPathGenerator = new SmoothPathGenerator()
            },
        };

        Diagram = new BlazorDiagram(options);

        var firstNode = Diagram.Nodes.Add(new NodeModel(position: new Point(50, 50))
        {
            Title = "Node 1",
        });

        firstNode.AddPort(PortAlignment.Left);
        var right1 = firstNode.AddPort(PortAlignment.Right);
        var secondNode = Diagram.Nodes.Add(new NodeModel(position: new Point(200, 100))
        {
            Title = "Node 2",
        });
        var leftPort = secondNode.AddPort(PortAlignment.Left);
        var rightPort = secondNode.AddPort(PortAlignment.Right);

        // The connection point will be the intersection of
        // a line going from the target to the center of the source
        var sourceAnchor = new SinglePortAnchor(right1);
        // The connection point will be the port's position
        var targetAnchor = new SinglePortAnchor(leftPort);
        var link = Diagram.Links.Add(new LinkModel(sourceAnchor, targetAnchor));

        return Task.CompletedTask;

    }

    private Point myPointer = new Point(0, 0);

    private async Task DrawCircleAsync(Point point)
    {
        await using (var ctx = await canvas.GetContext2DAsync())
        {
            await using var batch = ctx.CreateBatch();
            await batch.ClearRectAsync(0, 0, 400, 400);
            await batch.FillStyleAsync("red");
            await batch.BeginPathAsync();
            await batch.ArcAsync(point.X, point.Y, 10, 0, 2 * Math.PI);
            await batch.FillAsync(FillRule.EvenOdd);
        }
    }

    private async void Callback(MouseEventArgs obj)
    {
        var point = new Point(obj.OffsetX, obj.OffsetY);

        await DrawCircleAsync(point);
    }

    public void Dispose()
    {
        Diagram = null;
    }

}
